AWSTemplateFormatVersion: 2010-09-09
Description: >-
  AWS Step Functions for Aged Snapshot identification and Cleanup with Human based approvals. It sends an email with an HTTP
  URL for approval.

Parameters:
  SnapshotAge:
    Type: Number
    Default: 365
    Description: Enter number to get the Aged snapshot details and then delete.
  AgedSnapshotFileName:
    Type: String
    Default: Kantar_AWS_AgedSnapshots_
    Description: Enter AgedSnapshot Report name
  AgedSnapshotFileType:
    Type: String
    Default: .csv
    Description: Enter AgedSnapshot Report Type
  S3Bucket:
    Type: String
    Default: kitp-backups
    Description: Enter S3 Bucket name    
  S3Prefix:
    Type: String
    Default: AgedSnapshotDetails/
    Description: Enter S3 Prefix name
  Receiver:
    Type: String
    Default: mahender.gocica@kyndryl.com
    Description: Enter email id to receive the Aged Snapshot Report. 
  Sender: 
    Type: String
    Default: mahender.gocica@kyndryl.com
    Description: Enter email id to sender the Aged Snapshot Report. 

Resources:
  ExecutionApi:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Name: Human approval endpoint
      Description: HTTP Endpoint backed by API Gateway and Lambda
      FailOnWarnings: true
  ExecutionResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ExecutionApi
      ParentId: !GetAtt ExecutionApi.RootResourceId
      PathPart: execution
  ExecutionMethod:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      AuthorizationType: NONE
      HttpMethod: GET
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub >-
          arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaApprovalsFunction.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 302
            ResponseParameters:
              method.response.header.Location: integration.response.body.headers.Location
        RequestTemplates:
          application/json: |
            {
              "body" : $input.json('$'),
              "headers": {
                #foreach($header in $input.params().header.keySet())
                "$header": "$util.escapeJavaScript($input.params().header.get($header))" #if($foreach.hasNext),#end

                #end
              },
              "method": "$context.httpMethod",
              "params": {
                #foreach($param in $input.params().path.keySet())
                "$param": "$util.escapeJavaScript($input.params().path.get($param))" #if($foreach.hasNext),#end

                #end
              },
              "query": {
                #foreach($queryParam in $input.params().querystring.keySet())
                "$queryParam": "$util.escapeJavaScript($input.params().querystring.get($queryParam))" #if($foreach.hasNext),#end

                #end
              }  
            }
      ResourceId: !Ref ExecutionResource
      RestApiId: !Ref ExecutionApi
      MethodResponses:
        - StatusCode: 302
          ResponseParameters:
            method.response.header.Location: true
  ApiGatewayAccount:
    Type: 'AWS::ApiGateway::Account'
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchLogsRole.Arn
  ApiGatewayCloudWatchLogsRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - apigateway.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: ApiGatewayLogsPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:*'
                Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
  ExecutionApiStage:
    DependsOn:
      - ApiGatewayAccount
    Type: 'AWS::ApiGateway::Stage'
    Properties:
      DeploymentId: !Ref ApiDeployment
      MethodSettings:
        - DataTraceEnabled: true
          HttpMethod: '*'
          LoggingLevel: INFO
          ResourcePath: /*
      RestApiId: !Ref ExecutionApi
      StageName: states
  ApiDeployment:
    Type: 'AWS::ApiGateway::Deployment'
    DependsOn:
      - ExecutionMethod
    Properties:
      RestApiId: !Ref ExecutionApi
      StageName: DummyStage
  LambdaApprovalsFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Code:
        ZipFile:
          'Fn::Sub': >
            const AWS = require('aws-sdk');

            var redirectToStepFunctions = function(lambdaArn, statemachineName,
            executionName, callback) {
              const lambdaArnTokens = lambdaArn.split(":");
              const partition = lambdaArnTokens[1];
              const region = lambdaArnTokens[3];
              const accountId = lambdaArnTokens[4];

              console.log("partition=" + partition);
              console.log("region=" + region);
              console.log("accountId=" + accountId);

              const executionArn = "arn:" + partition + ":states:" + region + ":" + accountId + ":execution:" + statemachineName + ":" + executionName;
              console.log("executionArn=" + executionArn);

              const url = "https://console.aws.amazon.com/states/home?region=" + region + "#/executions/details/" + executionArn;
              callback(null, {
                  statusCode: 302,
                  headers: {
                    Location: url
                  }
              });
            };


            exports.handler = (event, context, callback) => {
              console.log('Event= ' + JSON.stringify(event));
              const action = event.query.action;
              const taskToken = event.query.taskToken;
              const statemachineName = event.query.sm;
              const executionName = event.query.ex;

              const stepfunctions = new AWS.StepFunctions();

              var message = "";

              if (action === "approve") {
                message = { "Status": "Approved!" };
              } else if (action === "reject") {
                message = { "Status": "Rejected!" };
              } else {
                console.error("Unrecognized action. Expected: approve, reject.");
                callback({"Status": "Failed to process the request. Unrecognized Action."});
              }

              stepfunctions.sendTaskSuccess({
                output: JSON.stringify(message),
                taskToken: event.query.taskToken
              })
              .promise()
              .then(function(data) {
                redirectToStepFunctions(context.invokedFunctionArn, statemachineName, executionName, callback);
              }).catch(function(err) {
                console.error(err, err.stack);
                callback(err);
              });
            }
      Description: Lambda function that callback to AWS Step Functions
      FunctionName: LambdaApprovalsFunction
      Handler: index.handler
      Role: !GetAtt LambdaApiGatewayIAMRole.Arn
      Runtime: nodejs12.x
  LambdaApiGatewayInvoke:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !GetAtt LambdaApprovalsFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ExecutionApi}/*'
  LambdaApiGatewayIAMRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
      Policies:
        - PolicyName: CloudWatchLogsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:*'
                Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
        - PolicyName: StepFunctionsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'states:SendTaskFailure'
                  - 'states:SendTaskSuccess'
                Resource: '*'
  HumanApprovalLambdaStateMachine:
    Type: 'AWS::StepFunctions::StateMachine'
    Properties:
      RoleArn: !GetAtt LambdaStateMachineExecutionRole.Arn
      DefinitionString:
        'Fn::Sub': |
          {
            "StartAt": "Lambda GetAgedSnapshotDetails",
            "TimeoutSeconds": 1296000,
            "States": {
              "Lambda GetAgedSnapshotDetails": {
                "Type": "Task",
                "Resource": "arn:aws:states:::lambda:invoke",
                "Parameters": {
                  "FunctionName": "${LambdaFunctionAgedSnapshot.Arn}"
                },
                "Next": "Lambda Callback"
              },
              "Lambda Callback": {
                "Type": "Task",
                "Resource": "arn:${AWS::Partition}:states:::lambda:invoke.waitForTaskToken",
                "Parameters": {
                  "FunctionName": "${LambdaHumanApprovalSendEmailFunction.Arn}",
                  "Payload": {
                    "ExecutionContext.$": "$$",
                    "APIGatewayEndpoint": "https://${ExecutionApi}.execute-api.${AWS::Region}.amazonaws.com/states"
                  }
                },
                "Next": "ManualApprovalChoiceState"
              },
              "ManualApprovalChoiceState": {
                "Type": "Choice",
                "Choices": [
                  {
                    "Variable": "$.Status",
                    "StringEquals": "Approved!",
                    "Next": "ApprovedPassState"
                  },
                  {
                    "Variable": "$.Status",
                    "StringEquals": "Rejected!",
                    "Next": "RejectedPassState"
                  }
                ]
              },
              "ApprovedPassState": {
                "Type": "Task",
                "Resource": "arn:aws:states:::lambda:invoke",
                "Parameters": {
                  "FunctionName": "${LambdaFunctionDeleteSnapshot.Arn}"
                },
                "Next": "Approvals_FinalStep"
              },
              "Approvals_FinalStep": {
                "Type": "Pass",
                "End": true
              },
              "RejectedPassState": {
                "Type": "Task",
                "Resource": "arn:aws:states:::lambda:invoke",
                "Parameters": {
                  "FunctionName": "${LambdaFunctionRejectEmail.Arn}"
                },
                "Next": "Rejected_FinalStep"
              },
              "Rejected_FinalStep": {
                "Type": "Pass",
                "End": true
              }
            }
          }
  LambdaFunctionAgedSnapshot:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaSendEmailExecutionRole.Arn
      Runtime: python3.9
      MemorySize: 512
      Environment:
        Variables:
          File: 
            Ref: AgedSnapshotFileName
          FileType: 
            Ref: AgedSnapshotFileType
          Prefix: 
            Ref: S3Prefix
          Receiver:
            Ref: Receiver
          S3_Bucket:
            Ref: S3Bucket
          Sender: 
            Ref: Sender
          SnapshotAge: 
            Ref: SnapshotAge
      Timeout: '600'
      Code:
        ZipFile:
          'Fn::Sub': |
            ###########################################################################################################################
            #Author: Mahender Gocica <mahender.gocica@kyndryl.com>
            #Version: 0.1
            #Description: Script is used for Fetching the one year old AWS Cloud EBS Volume Snapshots, AMI and associated Snapshots.
            # 1. Conect to specific AWS Cloud Reagions [us-east-1 and eu-west-1]
            # 2. Based on condition No.Of Days it will Identify the Aged Sanpshots (EBS and AMI Associated Snapshots).
            # Permission
            # 3. Send attached list of Aged Snapshots over email to business to review and get approvals to Cleanup the Aged AMI's and Snapshots.
            # #########################################################################################################################
            import json
            import boto3
            import re
            import csv
            import os
            from datetime import datetime
            from datetime import timedelta, timezone
            from dateutil.relativedelta import relativedelta
            import time
            import smtplib
            import sys
            from io import StringIO
            from email.generator import Generator
            from os.path import basename
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            from email.mime.application import MIMEApplication
            import sys
            import logging
            import botocore
            from botocore.exceptions import ClientError

            # Log Debugging configurations
            logger = logging.getLogger()
            logger.setLevel(logging.INFO)
            handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logging.basicConfig(filename='SanpshotAMILogFile.log', filemode='w', format='%(asctime)s %(message)s', level=logging.DEBUG)
            Current_Date_Formatted=datetime.today().strftime('%Y-%m')
            logger.info("Current_Date_Formatted: - {}".format(Current_Date_Formatted))

            amis = {}
            amidnd = []
            AMIMorethenOneYearList=[]
            InstanceImageID=""
            used_amis=[]
            ImageAMIIDs=[]
            SnapshotID_NonAttachedtoAMI=[] 
            csvDataListMainUniqList=[]

            def lambda_handler(event, context): 
                try:
                    # Variable Declaration
                    path="/tmp/"
                    s3_bucket = os.environ['S3_Bucket'] ## Change Bucket Name
                    logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                    Prefix= os.environ['Prefix']
                    logger.info("S3 Folder Prefix: - {}".format(Prefix))
                    File = os.environ['File']
                    logger.info("S3 Upload File: - {}".format(File))
                    FileType=os.environ['FileType']
                    logger.info("S3 Upload File Type: - {}".format(FileType))
                    SnapshotAge=os.environ['SnapshotAge']
                    logger.info("SnapshotAge: - {}".format(SnapshotAge))
                    s3_key=Prefix+File+Current_Date_Formatted+FileType
                    report_name= File+Current_Date_Formatted+FileType
                    logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                    logger.info("S3 Key: - {}".format(s3_key))
                    logger.info("report_name: - {}".format(report_name))
                    SnapshotFileName=File+Current_Date_Formatted+FileType
                    lambda_path ="/tmp/"+SnapshotFileName
                    s3_path=Prefix+SnapshotFileName
                    
                    regions=['us-east-1','eu-west-1']
                    s3 = boto3.resource('s3',"eu-west-1")
                    s3_client = boto3.client('s3',"eu-west-1")
                    logger.info("In IdentifyAgedSnapshots Function!!!")
                    logger.info("In SnapshotFileName!!! - {}".format(SnapshotFileName))
                    with open(lambda_path, 'w+') as csvFile:
                        try:
                            writer = csv.writer(csvFile)
                            writer.writerow(['SnapshotId', 'AMIID','ImageName',"Snapshot Creation Date","SnapshotSize","Region"])
                            # Get all the snapshot and AMI details by connecting to each region with EC2 Client
                            for region in regions:
                                csvDataListMainList = []
                                csvDataListMainUniqList = []
                                client = boto3.client('ec2',region_name=region)
                                ami_response = client.describe_images(Owners=['self'])
                                snapshot_response = client.describe_snapshots(OwnerIds=['self'])
                                autoscaling = boto3.client('autoscaling')
                                lc_response = autoscaling.describe_launch_configurations()
                                
                                #AutoScalling AMI Information
                                for ami in lc_response['LaunchConfigurations']:
                                    amidnd.append(ami['ImageId'])
                                logger.info('AWS Connected to fetch Snapshot details- {}'.format(region))
                                snapshots = client.describe_snapshots(OwnerIds=['self'])
                                images = client.describe_images(Owners=['self'])
                                #Get the each snapshot details and identify which are created more than 365 days.
                                instances = client.describe_instances()
                                for reservation in instances['Reservations']:
                                    for instance in reservation['Instances']:
                                        used_amis.append(instance['ImageId'])
                                for i in range(len(snapshots['Snapshots'])):
                                    delete_time = ""
                                    StartTime = snapshots['Snapshots'][i]['StartTime']
                                    try:
                                      delete_time = datetime.now(tz=timezone.utc) - timedelta(days=int(SnapshotAge))
                                    except ValueError as e:
                                        logging.error('If any ValueError Excptions - {}'.format(e))   
                                    # Idenditifying AMI's which are created more than one year along with AMI and associated Snapshot details 
                                    if (delete_time.date() > StartTime.date()):
                                            SnapshotId = snapshots['Snapshots'][i]['SnapshotId']
                                            VolumeSize=snapshots['Snapshots'][i]['VolumeSize']
                                            '''Clean abandon ebs snapshots of which no AMI has been found'''
                                            snapdndids = []
                                            csvDataList = []
                                            AMISnapshotIDList=[]
                                            ImageIDList=[]
                                            BlockSanpshotIDlist=[]
                                            for image in images:
                                                if image == "ResponseMetadata":
                                                    mylist = len(images['Images'])
                                                    for i in range(mylist):
                                                        interlist = []
                                                        creation_date =  images['Images'][i]['CreationDate']
                                                        BlockDeviceMappings =  images['Images'][i]["BlockDeviceMappings"]
                                                        imgageid = images['Images'][i]['ImageId']
                                                        # try:
                                                        #     ec2 = boto3.resource('ec2',region)
                                                        #     image2 = ec2.Image(imgageid,region)
                                                        #     logger.info("lastLaunchedTime::::image2::::",image2)
                                                        #     #response2 = image2.describe_attribute(Attribute='lastLaunchedTime')
                                                        #     #logger.info("lastLaunchedTime::::::::",response2)
                                                        # except IndexError as error:
                                                        #     # Output expected IndexErrors.
                                                        #     logger.info("lastLaunchedTime::::error::::{}".format(error))
                                                        #     #logging.log_exception(error)
                                                        # except Exception as exception:
                                                        #     # Output unexpected Exceptions.
                                                        #     #logging.log_exception(exception, False)  
                                                        #     logger.info("lastLaunchedTime::::exception::::{}".format(exception))
                                                        ImageIDList.append(imgageid)
                                                        Name=  images['Images'][i]['Name']
                                                        delete_time=""
                                                        try:
                                                            s = creation_date
                                                            f = "%Y-%m-%dT%H:%M:%S.%fZ"
                                                            creation_date_date = datetime.strptime(s, f)
                                                            delete_time = datetime.now(tz=timezone.utc) - timedelta(days=int(SnapshotAge))
                                                        except ValueError as e:
                                                            logging.error('If any ValueError Excptions - {}'.format(e)) 
                                                        if len(BlockDeviceMappings) > 1 and (delete_time.date() > creation_date_date.date()): 
                                                            
                                                            for j in range(len(BlockDeviceMappings)):
                                                                BlockSanpshotIDEBS =images['Images'][i]["BlockDeviceMappings"][j]
                                                                if "Ebs" in BlockSanpshotIDEBS:
                                                                    AMISanpshotID =images['Images'][i]["BlockDeviceMappings"][j]["Ebs"]["SnapshotId"]
                                                                    AMISnapshotIDList.append(AMISanpshotID)
                                                                    #Adding More than 1 year AMI ID's to List for Deregister AMIs
                                                                    AMIMorethenOneYearList.append(imgageid)
                                                                    if SnapshotId == AMISanpshotID and (imgageid not in used_amis):
                                                                        csvDataList.append(AMISanpshotID)
                                                                        csvDataList.append(imgageid)
                                                                        csvDataList.append(Name)
                                                                        ImageAMIIDs.append(imgageid)
                                                                        csvDataList.append(creation_date_date.date())
                                                                        csvDataList.append(VolumeSize)
                                                                        csvDataList.append(region)
                                                                        csvDataListMainList.append(csvDataList) 
                                                                    else:
                                                                        pass
            
                                            # # # Below condition is to add the Snapsohts details which are not in AMI snapshot ID's List
                                            if SnapshotId not in AMISnapshotIDList:
                                                try:
                                                    img = client.describe_images(Filters=[{'Name': 'block-device-mapping.snapshot-id', 'Values': [SnapshotId]}])
                                                    if (len(img['Images']) > 0):
                                                        ami_id = img['Images'][0]['ImageId']
                                                        print("Snapshot(" + SnapshotId + ") is associated to image(" + ami_id + "). Return True")
                                                        
                                                    else:
                                                        logger.info('Else - {}')
                                                        locallist=[]
                                                        print("Snapshot(" + SnapshotId + ") is not associated to any image. Return False")
                                                        locallist.append(SnapshotId)
                                                        locallist.append("")
                                                        locallist.append("")
                                                        locallist.append(StartTime.date())
                                                        locallist.append(VolumeSize)
                                                        locallist.append(region)
                                                        csvDataListMainList.append(locallist)
                                                except botocore.exceptions.ClientError as error:
                                                        if error.response['Error']['Code'] == 'InvalidSnapshot.InUse':
                                                            logger.info('SnapShotId '+SnapshotId+' is already being used by an AMI')
                                                        else:
                                                            logger.info("In ELSE ELSE::::::::")
                                                            pass
                                                logger.info('Final List -- csvDataListMainList-- of Snapshot Details - {}'.format(csvDataListMainList))
                                            else:
                                                pass
                                                            
                                            csvDataListMainUniqList = []
                                            for ele in csvDataListMainList:
                                                if set(ele) not in [set(x) for x in csvDataListMainUniqList]:
                                                    csvDataListMainUniqList.append(ele)
                                logger.info('Print Final List -- csvDataListMainList-- of Snapshot Details - {}'.format(csvDataListMainList))
                                logger.info('Print Final List--csvDataListMainUniqList-- of Snapshot Details - {}'.format(csvDataListMainUniqList))
                                #Writing Data into output file
                                for csvInfo in csvDataListMainUniqList:
                                    writer.writerow(csvInfo)
                        except Exception as exception:
                                logging.error('If any Exception occure - {}'.format(exception))
                            
                    logging.info('Snapshot Details Collected - {}')
                    csvFile.close()
                    try:
                      response = s3_client.upload_file(lambda_path, s3_bucket, s3_path)
                      logger.info('Snapshot Uploaded Successfully!!')
                    except ClientError as e:
                        logging.error(e)
                        return False
                    return {
                            'statusCode': 200,
                            'body': json.dumps('Lambda execution completed')
                        }    
                
                except Exception as exception:
                    # Output unexpected Exceptions.
                    logging.error('If any exceptions  - {}'.format(exception)) 
                    
  LambdaHumanApprovalSendEmailFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaSendEmailExecutionRole.Arn
      Runtime: python3.9
      MemorySize: 512
      Timeout: '600'
      Environment:
        Variables:
          File: 
            Ref: AgedSnapshotFileName
          FileType: 
            Ref: AgedSnapshotFileType
          Prefix: 
            Ref: S3Prefix
          Receiver:
            Ref: Receiver
          S3_Bucket:
            Ref: S3Bucket
          Sender: 
            Ref: Sender
          SnapshotAge: 
            Ref: SnapshotAge
      Code:
        ZipFile:
          'Fn::Sub': |
            import json
            import boto3
            import time
            import urllib.parse
            import datetime
            import os
            import botocore
            import urllib
            import sys

            from datetime import date
            from botocore.exceptions import ClientError
            from email.generator import Generator
            from os.path import basename
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            from email.mime.application import MIMEApplication

            import logging

            # Log Debugging configurations
            logger = logging.getLogger()
            logger.setLevel(logging.INFO)
            handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logging.basicConfig(filename='SanpshotAMILogFile.log', filemode='w', format='%(asctime)s %(message)s', level=logging.DEBUG)

            Current_Date_Formatted = datetime.datetime.today().strftime ('%Y-%m')
            logger.info("Current_Date_Formatted: - {}".format(Current_Date_Formatted))

            s3 = boto3.resource('s3')
            client = boto3.client('s3')

            print('Loading function')

            def lambda_handler(event, context):
                # TODO implement
                logger.info("event: - {}".format(event))
                apiEndpoint = event['APIGatewayEndpoint']
                logger.info("API Endpoint:: - {}".format(apiEndpoint))
                executionName = event['ExecutionContext']['Execution']['Name']
                logger.info("executionName:: - {}".format(executionName))
                statemachineName = event['ExecutionContext']['StateMachine']['Name']
                logger.info("statemachineName:: - {}".format(statemachineName))
                taskToken = event['ExecutionContext']['Task']['Token']
                logger.info("taskToken:: - {}".format(taskToken))
                approveEndpoint = apiEndpoint + "/execution?action=approve&ex=" + executionName + "&sm=" + statemachineName + "&taskToken=" + urllib.parse.quote(taskToken, safe='')
                logger.info("approveEndpoint:: - {}".format(approveEndpoint))
                
                rejectEndpoint = apiEndpoint + "/execution?action=reject&ex=" + executionName + "&sm=" + statemachineName + "&taskToken=" + urllib.parse.quote(taskToken, safe='')
                logger.info("rejectEndpoint:: - {}".format(rejectEndpoint))
                
                s3_bucket = os.environ['S3_Bucket'] ## Change Bucket Name
                logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                Prefix= os.environ['Prefix']
                logger.info("S3 Folder Prefix: - {}".format(Prefix))
                File = os.environ['File']
                logger.info("S3 Upload File: - {}".format(File))
                FileType=os.environ['FileType']
                logger.info("S3 Upload File Type: - {}".format(FileType))
                
                s3_key=Prefix+File+Current_Date_Formatted+FileType
                
                report_name= File+Current_Date_Formatted+FileType
                logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                logger.info("S3 Key: - {}".format(s3_key))
                logger.info("report_name: - {}".format(report_name))
                download_uri = "s3://" + s3_bucket + "/" + s3_key
                download_report = "/tmp/" + report_name
                logger.info("Downloading AgedSnapshot Report from S3 bucket to: - {}".format(download_report))
                
                try:
                    s3.meta.client.download_file(s3_bucket, s3_key, download_report)
                    logger.info("Downloaded AgedSnapshot Report from S3 bucket to: - {}".format(download_report))
                except botocore.exceptions.ClientError as e:
                    if e.response['Error']['Code'] == "404":
                        logging.debug("The object does not exist{}".format(e))
                    else:
                        raise

                # Send email using SES with attachment
                msg = MIMEMultipart()
                msg["Subject"] = "This is an email with an attachment!"
                Sender = os.environ['Sender']
                Receiver=os.environ['Receiver']
                logger.info("Sender: - {}".format(Sender))
                logger.info("Receiver: - {}".format(Receiver))
                msg["From"] = Sender      ## Modify to your "From" Address
                msg["To"] = Receiver        ## Modify to your "To" Address
                listtoemail=[]
                listtoemail.append(msg['To'])
                logger.info("listtoemail: - {}".format(listtoemail))
                # Set message body

                html = """<html>
                            <head></head>
                            <body>
                              <p>Hi <br><br>
                                Kantar AWS Aged Snapshot Details. Below are approvals and Reject Links <br>
                                Approval Link: '<a href="%s">Approve</a>' <br>
                                Reject Link: '<a href="%s">Reject</a>' <br><br>
                                Thank you <br>
                                ec-devops <br><br>
                                This is an automatic generated email, Please reachout to '<a href="kantar-aws-support@kyndryl.com">Kyndryl DevOps IT</a>' for any support/concerns.<br>
                              </p>
                            </body>
                            </html>
                                        """ %(approveEndpoint, rejectEndpoint )                       
                body = MIMEText(html, 'html')
                msg.attach(body)


                with open(download_report, "rb") as attachment:
                    part = MIMEApplication(attachment.read())
                    part.add_header("Content-Disposition",
                                    "attachment",
                                    filename=report_name)
                msg.attach(part)

                # Convert message to string and send
                ses_client = boto3.client("ses", region_name="eu-west-1")
                response = ses_client.send_raw_email(
                    Source=msg['From'],
                    Destinations=listtoemail,
                    RawMessage={"Data": msg.as_string()}
                )
                logger.info("Email Response: - {}".format(response))
                logger.info("Successfully sent email with report attachment")
  LambdaFunctionDeleteSnapshot:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaSendEmailExecutionRole.Arn
      Runtime: python3.9
      MemorySize: 512
      Environment:
        Variables:
          File: 
            Ref: AgedSnapshotFileName
          FileType: 
            Ref: AgedSnapshotFileType
          Prefix: 
            Ref: S3Prefix
          Receiver:
            Ref: Receiver
          S3_Bucket:
            Ref: S3Bucket
          Sender: 
            Ref: Sender
          SnapshotAge: 
            Ref: SnapshotAge
      Timeout: '600'
      Code:
        ZipFile:
          'Fn::Sub': |
            import json
            import boto3
            import time
            import urllib.parse
            import datetime
            import os
            import botocore
            import urllib
            import csv
            from datetime import date
            from botocore.exceptions import ClientError
            from email.generator import Generator
            from os.path import basename
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            from email.mime.application import MIMEApplication

            Current_Date_Formatted = datetime.datetime.today().strftime ('%Y-%m')
            print("Current_Date_Formatted:",Current_Date_Formatted)

            s3 = boto3.resource('s3')
            client = boto3.client('s3')

            print('Loading function')

            def lambda_handler(event, context):
                
                s3_bucket = os.environ['S3_Bucket'] ## Change Bucket Name
                logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                Prefix= os.environ['Prefix']
                logger.info("S3 Folder Prefix: - {}".format(Prefix))
                File = os.environ['File']
                logger.info("S3 Upload File: - {}".format(File))
                FileType=os.environ['FileType']
                logger.info("S3 Upload File Type: - {}".format(FileType))
                
                s3_key=Prefix+File+Current_Date_Formatted+FileType
                
                report_name= File+Current_Date_Formatted+FileType
                logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                logger.info("S3 Key: - {}".format(s3_key))
                logger.info("report_name: - {}".format(report_name))
                
                download_uri = "s3://" + s3_bucket + "/" + s3_key
                download_report = "/tmp/" + report_name
                print("Downloading AgedSnapshot Report from S3 bucket to ", download_report);
                
                try:
                    s3.meta.client.download_file(s3_bucket, s3_key, download_report)
                    print("Done.")
                    RowList=[]
                    AMIList=[]
                    SnapshotList=[]
                    with open(download_report, "r") as csvfile:
                        spamreader = csv.reader(csvfile, delimiter=",")
                        for row in spamreader:
                            currentrow=', '.join(row)
                            RowList.append(currentrow)
                            #RowList.
                            #AllList.append(RowList)
                            splitrow=currentrow.split(",")
                            #print("splitrow",splitrow[1])
                            if len(splitrow[1])>0:
                              AMIList.append(splitrow[1]) 
                              if splitrow[1] == ' ':
                                  SnapshotList.append(splitrow[0])
                    AMIFinalList = [ele for ele in AMIList if ele != ' '] 
                    AMIFinalList.pop(0)
                    print("FinalList List::::",AMIFinalList) 
                    print("EBS snapsohts:::",SnapshotList)
                    for imageid in AMIFinalList:
                        #response = client.deregister_image(ImageId=imageid)
                        print("Successfully Deregister ImageId:::::",imageid)
                    for SnapshotID in SnapshotList:
                        #response = client.delete_snapshot(SnapshotId='string')
                        print("Successfully Deleted SanpshotID:::::",SnapshotID)
                except botocore.exceptions.ClientError as e:
                    if e.response['Error']['Code'] == "404":
                        print("The object does not exist.")
                    else:
                        raise
                    
                # Send email using SES with attachment
                
                msg = MIMEMultipart()
                msg["Subject"] = "This is an email with an attachment!"
                Sender = os.environ['Sender']
                Receiver=os.environ['Receiver']
                logger.info("Sender: - {}".format(Sender))
                logger.info("Receiver: - {}".format(Receiver))
                msg["From"] = Sender      ## Modify to your "From" Address
                msg["To"] = Receiver        ## Modify to your "To" Address
                listtoemail=[]
                listtoemail.append(msg['To'])
                print(listtoemail)
                # Set message body

                html = """<html>
                            <head></head>
                            <body>
                              <p>Hi <br><br>
                                Attached list of Kantar AWS Aged Snapshot Cleandup. <br><br><br
                                Thank you <br>
                                KyndrylCloudOps <br><br>
                                This is an automatic generated email, Please reachout to '<a href="kantar-aws-support@kyndryl.com">KyndrylCloudOps</a>' for any support/concerns.<br>
                              </p>
                            </body>
                            </html>
                                        """                      
                body = MIMEText(html, 'html')
                msg.attach(body)
                with open(download_report, "rb") as attachment:
                    part = MIMEApplication(attachment.read())
                    part.add_header("Content-Disposition",
                                    "attachment",
                                    filename=report_name)
                msg.attach(part)

                # Convert message to string and send
                ses_client = boto3.client("ses", region_name="eu-west-1")
                response = ses_client.send_raw_email(
                    Source=msg['From'],
                    Destinations=listtoemail,
                    RawMessage={"Data": msg.as_string()}
                )
                print(response)
                print("Successfully sent email with report attachment")
  
  LambdaFunctionRejectEmail:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaSendEmailExecutionRole.Arn
      Runtime: python3.9
      MemorySize: 512
      Environment:
        Variables:
          File: 
            Ref: AgedSnapshotFileName
          FileType: 
            Ref: AgedSnapshotFileType
          Prefix: 
            Ref: S3Prefix
          Receiver:
            Ref: Receiver
          S3_Bucket:
            Ref: S3Bucket
          Sender: 
            Ref: Sender
          SnapshotAge: 
            Ref: SnapshotAge
      Timeout: '600'
      Code:
        ZipFile:
          'Fn::Sub': |
            import json
            import boto3
            import time
            import urllib.parse
            import datetime
            import os
            import botocore
            import urllib
            import csv
            import os
            import sys
            from datetime import date
            from botocore.exceptions import ClientError
            from email.generator import Generator
            from os.path import basename
            from email.mime.text import MIMEText
            from email.mime.multipart import MIMEMultipart
            from email.mime.application import MIMEApplication

            import logging

            # Log Debugging configurations
            logger = logging.getLogger()
            logger.setLevel(logging.INFO)
            handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logging.basicConfig(filename='SanpshotAMILogFile.log', filemode='w', format='%(asctime)s %(message)s', level=logging.DEBUG)

            Current_Date_Formatted = datetime.datetime.today().strftime ('%Y-%m')
            logger.info("Current_Date_Formatted: - {}".format(Current_Date_Formatted))

            s3 = boto3.resource('s3')
            client = boto3.client('s3')

            print('Loading function')

            def lambda_handler(event, context):
                s3_bucket = os.environ['S3_Bucket'] ## Change Bucket Name
                logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                Prefix= os.environ['Prefix']
                logger.info("S3 Folder Prefix: - {}".format(Prefix))
                File = os.environ['File']
                logger.info("S3 Upload File: - {}".format(File))
                FileType=os.environ['FileType']
                logger.info("S3 Upload File Type: - {}".format(FileType))
                s3_key=Prefix+File+Current_Date_Formatted+FileType
                report_name= File+Current_Date_Formatted+FileType
                logger.info("S3 Bucket Name: - {}".format(s3_bucket))
                logger.info("S3 Key: - {}".format(s3_key))
                logger.info("report_name: - {}".format(report_name))
                download_uri = "s3://" + s3_bucket + "/" + s3_key
                download_report = "/tmp/" + report_name
                logger.info("Downloading AgedSnapshot Report from S3 bucket to: - {}".format(download_report))
                
                try:
                    s3.meta.client.download_file(s3_bucket, s3_key, download_report)
                    logger.info("Downloaded AgedSnapshot Report from S3 bucket to: - {}".format(download_report))
                
                except botocore.exceptions.ClientError as e:
                    if e.response['Error']['Code'] == "404":
                      logging.debug("The object does not exist{}".format(e))
                    else:
                        raise
                    
                # Send email using SES with attachment
                
                msg = MIMEMultipart()
                Sender = os.environ['Sender']
                Receiver=os.environ['Receiver']
                logger.info("Sender: - {}".format(Sender))
                logger.info("Receiver: - {}".format(Receiver))
                msg["Subject"] = "Kantar Aged Snapshots needs to review!"
                msg["From"] = Sender      ## Modify to your "From" Address
                msg["To"] = Receiver        ## Modify to your "To" Address
                
                listtoemail=[]
                listtoemail.append(msg['To'])
                logger.info("listtoemail: - {}".format(listtoemail))
                # Set message body

                html = """<html>
                            <head></head>
                            <body>
                              <p>Hi <br><br>
                                Attached list of Kantar AWS Aged Snapshot list Needs to review . <br><br><br
                                Thank you <br>
                                KyndrylCloudOps <br><br>
                                This is an automatic generated email, Please reachout to '<a href="kantar-aws-support@kyndryl.com">KyndrylCloudOps</a>' for any support/concerns.<br>
                              </p>
                            </body>
                            </html>
                                        """                      
                body = MIMEText(html, 'html')
                msg.attach(body)
                with open(download_report, "rb") as attachment:
                    part = MIMEApplication(attachment.read())
                    part.add_header("Content-Disposition",
                                    "attachment",
                                    filename=report_name)
                msg.attach(part)

                # Convert message to string and send
                ses_client = boto3.client("ses", region_name="eu-west-1")
                response = ses_client.send_raw_email(
                    Source=msg['From'],
                    Destinations=listtoemail,
                    RawMessage={"Data": msg.as_string()}
                )
                logger.info("Email Response: - {}".format(response))
                logger.info("Successfully sent email with report attachment")
            
  LambdaStateMachineExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: InvokeCallbackLambda
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                Resource:
                  - !Sub '${LambdaHumanApprovalSendEmailFunction.Arn}'
                  - !Sub '${LambdaFunctionAgedSnapshot.Arn}'
                  - !Sub '${LambdaFunctionDeleteSnapshot.Arn}'
                  - !Sub '${LambdaFunctionRejectEmail.Arn}'
  LambdaSendEmailExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: CloudWatchLogsPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
        - PolicyName: SESSendEmailPolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'ses:SendEmail'
                  - 'ses:SendRawEmail'
                Resource: '*'
        - PolicyName: EC2andS3DescribeDeletePermission
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - 'ec2:Describe*'
                  - 'autoscaling:DescribeLaunchConfigurations'
                  - 'ec2:ModifySnapshotAttribute'
                  - 'ec2:GetEbsDefaultKmsKeyId'
                  - 'ec2:CreateTags'
                  - 'ec2:DeregisterImage'
                  - 'ec2:GetEbsEncryptionByDefault'
                  - 'ec2:DeleteSnapshot'
                  - 'ec2:DeleteTags'
                  - 's3:PutObject'
                  - 's3:GetObject'
                  - 's3:ListBucket'
                  - 's3:GetBucketPolicy'
                  - 's3:GetObject'
                  - 's3:GetObjectVersion'
                  - 's3:GetBucketLocation'
                Resource: '*'
Outputs:
  ApiGatewayInvokeURL:
    Value: !Sub 'https://${ExecutionApi}.execute-api.${AWS::Region}.amazonaws.com/states'
  StateMachineHumanApprovalArn:
    Value: !Ref HumanApprovalLambdaStateMachine
